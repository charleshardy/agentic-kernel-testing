"""Property-based tests for vulnerability pattern detection.

**Feature: agentic-kernel-testing, Property 33: Vulnerability pattern detection**

This test validates Requirements 7.3:
WHEN analyzing code, THE Testing System SHALL apply static analysis rules to detect 
common vulnerability patterns including buffer overflows, use-after-free, and integer overflows.
"""

import pytest
import tempfile
from pathlib import Path
from hypothesis import given, strategies as st, settings, assume
from analysis.security_scanner import (
    SecurityScanner,
    VulnerabilityType,
    Severity,
    SecurityIssue
)


# Strategies for generating code with known vulnerabilities

@st.composite
def buffer_overflow_code(draw):
    """Generate C code with buffer overflow vulnerability."""
    templates = [
        """
void vulnerable_function(char *input) {{
    char buffer[64];
    strcpy(buffer, input);  // Buffer overflow
    return;
}}
""",
        """
void process_data(char *data) {{
    char dest[128];
    strcat(dest, data);  // Buffer overflow
    printf("%s", dest);
}}
""",
        """
void format_string(char *user_input) {{
    char output[256];
    sprintf(output, user_input);  // Buffer overflow
    return;
}}
""",
        """
void read_input() {{
    char buffer[100];
    gets(buffer);  // Buffer overflow
    process(buffer);
}}
"""
    ]
    
    return draw(st.sampled_from(templates))


@st.composite
def use_after_free_code(draw):
    """Generate C code with use-after-free vulnerability."""
    templates = [
        """
void vulnerable_free(struct data *ptr) {{
    kfree(ptr);
    ptr->value = 10;  // Use after free
    return;
}}
""",
        """
void process_node(struct node *n) {{
    kfree(n);
    if (n->next != NULL) {{  // Use after free
        process_node(n->next);
    }}
}}
""",
        """
void cleanup_data(void *data) {{
    kfree(data);
    memset(data, 0, sizeof(*data));  // Use after free
}}
"""
    ]
    
    return draw(st.sampled_from(templates))


@st.composite
def integer_overflow_code(draw):
    """Generate C code with integer overflow vulnerability."""
    templates = [
        """
int calculate_size(int a, int b) {{
    int result = a + b;  // Integer overflow
    return result;
}}
""",
        """
size_t allocate_buffer(size_t count, size_t size) {{
    size_t total = count * size;  // Integer overflow
    return kmalloc(total, GFP_KERNEL);
}}
""",
        """
unsigned int compute_total(unsigned int x, unsigned int y) {{
    unsigned int sum = x + y;  // Integer overflow
    return sum;
}}
"""
    ]
    
    return draw(st.sampled_from(templates))


@st.composite
def null_pointer_deref_code(draw):
    """Generate C code with null pointer dereference."""
    templates = [
        """
void process_data(void) {{
    struct data *ptr = kmalloc(sizeof(*ptr), GFP_KERNEL);
    ptr->value = 42;  // Null pointer dereference
    return;
}}
""",
        """
int get_value(void) {{
    int *p = kzalloc(sizeof(int), GFP_KERNEL);
    return *p;  // Null pointer dereference
}}
""",
        """
void init_struct(void) {{
    struct node *n = kmalloc(sizeof(*n), GFP_KERNEL);
    n->next = NULL;  // Null pointer dereference
}}
"""
    ]
    
    return draw(st.sampled_from(templates))


@st.composite
def format_string_code(draw):
    """Generate C code with format string vulnerability."""
    templates = [
        """
void log_message(char *msg) {{
    printk(msg);  // Format string vulnerability
}}
""",
        """
void debug_output(char *user_data) {{
    char buffer[256];
    sprintf(buffer, user_data);  // Format string vulnerability
    return;
}}
""",
        """
void print_error(char *error) {{
    printk(KERN_ERR error);  // Format string vulnerability
}}
"""
    ]
    
    return draw(st.sampled_from(templates))


@st.composite
def multi_vulnerability_code(draw):
    """Generate C code with multiple vulnerability types."""
    buffer_overflow = draw(buffer_overflow_code())
    use_after_free = draw(use_after_free_code())
    integer_overflow = draw(integer_overflow_code())
    null_deref = draw(null_pointer_deref_code())
    format_string = draw(format_string_code())
    
    # Combine all vulnerabilities
    return f"""
{buffer_overflow}

{use_after_free}

{integer_overflow}

{null_deref}

{format_string}
"""


# Property 33: Vulnerability pattern detection
# For any code analyzed, the system should detect common vulnerability patterns 
# including buffer overflows, use-after-free, and integer overflows.

@given(code=buffer_overflow_code())
@settings(max_examples=100, deadline=None)
def test_buffer_overflow_detection(code):
    """Property: All buffer overflow patterns should be detected.
    
    **Validates: Requirements 7.3**
    """
    scanner = SecurityScanner()
    
    # Write code to temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
        f.write(code)
        temp_file = f.name
    
    try:
        # Scan the file
        issues = scanner.scan_file(temp_file)
        
        # Property: At least one buffer overflow should be detected
        buffer_overflow_issues = [
            issue for issue in issues
            if issue.vulnerability_type == VulnerabilityType.BUFFER_OVERFLOW
        ]
        
        assert len(buffer_overflow_issues) > 0, \
            "Failed to detect buffer overflow vulnerability"
        
        # Property: Detected issues should have proper metadata
        for issue in buffer_overflow_issues:
            assert issue.severity in [Severity.HIGH, Severity.CRITICAL]
            assert issue.description
            assert issue.file_path == temp_file
            assert issue.line_number > 0
            assert issue.recommendation
            assert "buffer" in issue.description.lower() or "overflow" in issue.description.lower()
    
    finally:
        # Clean up
        Path(temp_file).unlink(missing_ok=True)


@given(code=use_after_free_code())
@settings(max_examples=100, deadline=None)
def test_use_after_free_detection(code):
    """Property: All use-after-free patterns should be detected.
    
    **Validates: Requirements 7.3**
    """
    scanner = SecurityScanner()
    
    # Write code to temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
        f.write(code)
        temp_file = f.name
    
    try:
        # Scan the file
        issues = scanner.scan_file(temp_file)
        
        # Property: At least one use-after-free should be detected
        uaf_issues = [
            issue for issue in issues
            if issue.vulnerability_type == VulnerabilityType.USE_AFTER_FREE
        ]
        
        assert len(uaf_issues) > 0, \
            "Failed to detect use-after-free vulnerability"
        
        # Property: Detected issues should have proper metadata
        for issue in uaf_issues:
            assert issue.severity in [Severity.HIGH, Severity.CRITICAL]
            assert issue.description
            assert issue.file_path == temp_file
            assert issue.line_number > 0
            assert issue.recommendation
    
    finally:
        # Clean up
        Path(temp_file).unlink(missing_ok=True)


@given(code=integer_overflow_code())
@settings(max_examples=100, deadline=None)
def test_integer_overflow_detection(code):
    """Property: All integer overflow patterns should be detected.
    
    **Validates: Requirements 7.3**
    """
    scanner = SecurityScanner()
    
    # Write code to temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
        f.write(code)
        temp_file = f.name
    
    try:
        # Scan the file
        issues = scanner.scan_file(temp_file)
        
        # Property: At least one integer overflow should be detected
        overflow_issues = [
            issue for issue in issues
            if issue.vulnerability_type == VulnerabilityType.INTEGER_OVERFLOW
        ]
        
        assert len(overflow_issues) > 0, \
            "Failed to detect integer overflow vulnerability"
        
        # Property: Detected issues should have proper metadata
        for issue in overflow_issues:
            assert issue.severity in [Severity.MEDIUM, Severity.HIGH, Severity.CRITICAL]
            assert issue.description
            assert issue.file_path == temp_file
            assert issue.line_number > 0
            assert "overflow" in issue.description.lower() or "integer" in issue.description.lower()
    
    finally:
        # Clean up
        Path(temp_file).unlink(missing_ok=True)


@given(code=multi_vulnerability_code())
@settings(max_examples=50, deadline=None)
def test_multiple_vulnerability_detection(code):
    """Property: System should detect all vulnerability types when multiple are present.
    
    **Validates: Requirements 7.3**
    
    This is the main completeness property: when code contains multiple vulnerability
    types, ALL of them should be detected.
    """
    scanner = SecurityScanner()
    
    # Write code to temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
        f.write(code)
        temp_file = f.name
    
    try:
        # Scan the file
        issues = scanner.scan_file(temp_file)
        
        # Property: Multiple vulnerability types should be detected
        detected_types = {issue.vulnerability_type for issue in issues}
        
        # We expect at least 3 different types since we injected multiple types
        assert len(detected_types) >= 3, \
            f"Expected multiple vulnerability types, found {len(detected_types)}"
        
        # Property: Should detect buffer overflow
        assert VulnerabilityType.BUFFER_OVERFLOW in detected_types, \
            "Failed to detect buffer overflow when present"
        
        # Property: Should detect use-after-free
        assert VulnerabilityType.USE_AFTER_FREE in detected_types, \
            "Failed to detect use-after-free when present"
        
        # Property: Should detect integer overflow
        assert VulnerabilityType.INTEGER_OVERFLOW in detected_types, \
            "Failed to detect integer overflow when present"
        
        # Property: Each issue should have complete metadata
        for issue in issues:
            assert issue.timestamp is not None
            assert issue.description
            assert issue.severity in [Severity.LOW, Severity.MEDIUM, Severity.HIGH, Severity.CRITICAL]
            assert issue.file_path == temp_file
            assert issue.line_number > 0
            assert 0.0 <= issue.confidence <= 1.0
    
    finally:
        # Clean up
        Path(temp_file).unlink(missing_ok=True)


@given(
    buffer_count=st.integers(min_value=1, max_value=3),
    uaf_count=st.integers(min_value=1, max_value=3),
    overflow_count=st.integers(min_value=1, max_value=3)
)
@settings(max_examples=30, deadline=None)
def test_detection_count_accuracy(buffer_count, uaf_count, overflow_count):
    """Property: Number of detected vulnerabilities should match number present.
    
    **Validates: Requirements 7.3**
    """
    # Generate code with specific number of each vulnerability type
    code_parts = []
    
    # Add buffer overflows
    for i in range(buffer_count):
        code_parts.append(f"""
void buffer_vuln_{i}(char *input) {{
    char buf[64];
    strcpy(buf, input);
}}
""")
    
    # Add use-after-free
    for i in range(uaf_count):
        code_parts.append(f"""
void uaf_vuln_{i}(struct data *ptr) {{
    kfree(ptr);
    ptr->value = {i};
}}
""")
    
    # Add integer overflows
    for i in range(overflow_count):
        code_parts.append(f"""
int overflow_vuln_{i}(int a, int b) {{
    int result = a + b;
    return result;
}}
""")
    
    code = "\n".join(code_parts)
    
    scanner = SecurityScanner()
    
    # Write code to temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
        f.write(code)
        temp_file = f.name
    
    try:
        # Scan the file
        issues = scanner.scan_file(temp_file)
        
        # Count detected vulnerabilities by type
        detected_buffer = len([
            i for i in issues
            if i.vulnerability_type == VulnerabilityType.BUFFER_OVERFLOW
        ])
        detected_uaf = len([
            i for i in issues
            if i.vulnerability_type == VulnerabilityType.USE_AFTER_FREE
        ])
        detected_overflow = len([
            i for i in issues
            if i.vulnerability_type == VulnerabilityType.INTEGER_OVERFLOW
        ])
        
        # Property: Detection count should match or exceed injection count
        # (may be higher due to multiple detections per vulnerability)
        assert detected_buffer >= buffer_count, \
            f"Expected at least {buffer_count} buffer overflows, detected {detected_buffer}"
        assert detected_uaf >= uaf_count, \
            f"Expected at least {uaf_count} use-after-free, detected {detected_uaf}"
        assert detected_overflow >= overflow_count, \
            f"Expected at least {overflow_count} integer overflows, detected {detected_overflow}"
    
    finally:
        # Clean up
        Path(temp_file).unlink(missing_ok=True)


@given(code=st.text(alphabet=st.characters(whitelist_categories=('L', 'N', 'P')), min_size=50, max_size=500))
@settings(max_examples=100, deadline=None)
def test_no_false_positives_on_safe_code(code):
    """Property: Safe code without vulnerabilities should not trigger false detections.
    
    **Validates: Requirements 7.3**
    """
    # Ensure code doesn't contain vulnerability patterns
    vuln_keywords = [
        "strcpy", "strcat", "sprintf", "gets",
        "kfree", "kmalloc", "kzalloc",
        "printk"
    ]
    
    # Skip if code contains vulnerability keywords
    assume(not any(keyword in code for keyword in vuln_keywords))
    
    scanner = SecurityScanner()
    
    # Write code to temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
        f.write(code)
        temp_file = f.name
    
    try:
        # Scan the file
        issues = scanner.scan_file(temp_file)
        
        # Property: No vulnerabilities should be detected in safe code
        # Allow for some false positives due to regex patterns
        assert len(issues) <= 2, \
            f"Too many false positives: detected {len(issues)} issues in safe code"
    
    finally:
        # Clean up
        Path(temp_file).unlink(missing_ok=True)


def test_report_generation_completeness():
    """Property: Security report should include all required information.
    
    **Validates: Requirements 7.3**
    """
    scanner = SecurityScanner()
    
    # Create test code with known vulnerabilities
    code = """
void test_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);
    
    struct data *ptr = kmalloc(sizeof(*ptr), GFP_KERNEL);
    kfree(ptr);
    ptr->value = 10;
    
    int result = input[0] + input[1];
}
"""
    
    # Write code to temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
        f.write(code)
        temp_file = f.name
    
    try:
        # Scan the file
        issues = scanner.scan_file(temp_file)
        scan_results = {temp_file: issues}
        
        # Generate report
        report = scanner.generate_report(scan_results)
        
        # Property: Report should have all required fields
        assert "scan_timestamp" in report
        assert "total_files_scanned" in report
        assert "total_issues" in report
        assert "severity_breakdown" in report
        assert "vulnerability_types" in report
        assert "files_with_issues" in report
        
        # Property: Severity breakdown should have all levels
        assert "critical" in report["severity_breakdown"]
        assert "high" in report["severity_breakdown"]
        assert "medium" in report["severity_breakdown"]
        assert "low" in report["severity_breakdown"]
        
        # Property: Total issues should match sum of severity counts
        total_by_severity = sum(report["severity_breakdown"].values())
        assert report["total_issues"] == total_by_severity
        
        # Property: Files with issues should contain our test file
        assert temp_file in report["files_with_issues"]
        
        # Property: Each issue in report should have complete data
        for file_path, file_issues in report["files_with_issues"].items():
            for issue_dict in file_issues:
                assert "vulnerability_type" in issue_dict
                assert "severity" in issue_dict
                assert "file_path" in issue_dict
                assert "line_number" in issue_dict
                assert "description" in issue_dict
                assert "confidence" in issue_dict
    
    finally:
        # Clean up
        Path(temp_file).unlink(missing_ok=True)


def test_scanner_statistics():
    """Property: Scanner statistics should accurately reflect scan history.
    
    **Validates: Requirements 7.3**
    """
    scanner = SecurityScanner()
    
    # Perform multiple scans
    code_samples = [
        "void test1() { char buf[64]; strcpy(buf, input); }",
        "void test2() { struct data *p = kmalloc(sizeof(*p), GFP_KERNEL); kfree(p); p->value = 1; }",
        "void test3() { int x = a + b; }"
    ]
    
    temp_files = []
    
    try:
        for i, code in enumerate(code_samples):
            with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
                f.write(code)
                temp_file = f.name
                temp_files.append(temp_file)
                scanner.scan_file(temp_file)
        
        # Get statistics
        stats = scanner.get_statistics()
        
        # Property: Statistics should be complete
        assert "total_scans" in stats
        assert "total_files_scanned" in stats
        assert "total_issues_found" in stats
        assert "scan_history" in stats
        
        # Property: Total scans should match number of scans performed
        assert stats["total_scans"] == len(code_samples)
        
        # Property: Total files scanned should match unique files
        assert stats["total_files_scanned"] == len(code_samples)
        
        # Property: Scan history should contain recent scans
        assert len(stats["scan_history"]) <= 10
        assert len(stats["scan_history"]) == min(len(code_samples), 10)
    
    finally:
        # Clean up
        for temp_file in temp_files:
            Path(temp_file).unlink(missing_ok=True)


@given(code=null_pointer_deref_code())
@settings(max_examples=100, deadline=None)
def test_null_pointer_dereference_detection(code):
    """Property: Null pointer dereferences should be detected.
    
    **Validates: Requirements 7.3**
    """
    scanner = SecurityScanner()
    
    # Write code to temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
        f.write(code)
        temp_file = f.name
    
    try:
        # Scan the file
        issues = scanner.scan_file(temp_file)
        
        # Property: At least one null pointer dereference should be detected
        null_deref_issues = [
            issue for issue in issues
            if issue.vulnerability_type == VulnerabilityType.NULL_POINTER_DEREFERENCE
        ]
        
        assert len(null_deref_issues) > 0, \
            "Failed to detect null pointer dereference vulnerability"
        
        # Property: Detected issues should have proper metadata
        for issue in null_deref_issues:
            assert issue.severity in [Severity.MEDIUM, Severity.HIGH, Severity.CRITICAL]
            assert issue.description
            assert issue.file_path == temp_file
            assert issue.line_number > 0
    
    finally:
        # Clean up
        Path(temp_file).unlink(missing_ok=True)


@given(code=format_string_code())
@settings(max_examples=100, deadline=None)
def test_format_string_detection(code):
    """Property: Format string vulnerabilities should be detected.
    
    **Validates: Requirements 7.3**
    """
    scanner = SecurityScanner()
    
    # Write code to temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
        f.write(code)
        temp_file = f.name
    
    try:
        # Scan the file
        issues = scanner.scan_file(temp_file)
        
        # Property: At least one format string vulnerability should be detected
        format_issues = [
            issue for issue in issues
            if issue.vulnerability_type == VulnerabilityType.FORMAT_STRING
        ]
        
        assert len(format_issues) > 0, \
            "Failed to detect format string vulnerability"
        
        # Property: Detected issues should have proper metadata
        for issue in format_issues:
            assert issue.severity in [Severity.MEDIUM, Severity.HIGH, Severity.CRITICAL]
            assert issue.description
            assert issue.file_path == temp_file
            assert issue.line_number > 0
            assert "format" in issue.description.lower() or "string" in issue.description.lower()
    
    finally:
        # Clean up
        Path(temp_file).unlink(missing_ok=True)
