"""Property Test Generator for Agentic AI Test Requirements.

Generates Hypothesis-based property tests from correctness properties.
Tests include traceability annotations and are configured for minimum 100 iterations.
"""

import ast
import uuid
from typing import List, Dict, Any, Optional
from datetime import datetime
import textwrap

from .models import (
    CorrectnessProperty,
    PropertyPattern,
    GeneratedTest,
    ParsedRequirement,
    TypeSpecification,
)


class PropertyTestGenerator:
    """Generates Hypothesis property-based tests from correctness properties.
    
    Creates pytest-compatible test files with:
    - Proper imports and decorators
    - Traceability annotations in docstrings
    - Minimum 100 iterations configuration
    - Domain-specific generators
    """
    
    # Template for test file header
    FILE_HEADER_TEMPLATE = '''"""Property-based tests for {spec_name}.

Auto-generated by Agentic AI Test Requirements system.
Generated at: {timestamp}

Traceability:
- Specification: {spec_id}
- Requirements: {requirement_ids}
"""

import pytest
from hypothesis import given, settings, assume, note, Verbosity
from hypothesis import strategies as st
from typing import Any, Dict, List, Optional

# Import domain-specific generators
try:
    from ai_generator.requirements.generator_factory import (
        GeneratorFactory,
        create_generator,
        create_domain_generator,
    )
    from ai_generator.requirements.models import TypeSpecification
    GENERATORS_AVAILABLE = True
except ImportError:
    GENERATORS_AVAILABLE = False

# Test configuration
MIN_ITERATIONS = 100
TEST_TIMEOUT = 300  # seconds

'''

    # Template for individual test function
    TEST_FUNCTION_TEMPLATE = '''
@settings(max_examples={iterations}, deadline=None, verbosity=Verbosity.verbose)
@given({generators})
def test_{test_name}({params}):
    """Property: {property_name}
    
    {description}
    
    Universal Quantifier: {universal_quantifier}
    Property Statement: {property_statement}
    
    Traceability:
    - Property ID: {property_id}
    - Requirements: {requirement_ids}
    - Pattern: {pattern}
    
    Preconditions:
{preconditions}
    
    Postconditions:
{postconditions}
    """
{test_body}
'''

    def __init__(self, llm_provider: Optional[Any] = None):
        """Initialize the property test generator.
        
        Args:
            llm_provider: Optional LLM provider for intelligent generation
        """
        self.llm_provider = llm_provider
    
    def generate_test(self, prop: CorrectnessProperty) -> GeneratedTest:
        """Generate a property-based test from a correctness property.
        
        Args:
            prop: CorrectnessProperty to generate test for
            
        Returns:
            GeneratedTest object with test code
        """
        test_id = f"test_{uuid.uuid4().hex[:8]}"
        test_name = self._sanitize_name(prop.name)
        
        # Generate test code based on property pattern
        test_code = self._generate_test_code(prop, test_name)
        
        # Determine generators needed
        generators = self._identify_generators(prop)
        
        return GeneratedTest(
            id=test_id,
            name=test_name,
            property_id=prop.id,
            requirement_ids=prop.requirement_ids,
            test_code=test_code,
            generators=generators,
            iterations=100,
            timeout_seconds=300,
            metadata={
                'pattern': prop.pattern.value,
                'universal_quantifier': prop.universal_quantifier,
            }
        )
    
    def generate_test_file(
        self,
        properties: List[CorrectnessProperty],
        spec_id: str,
        spec_name: str,
        output_path: Optional[str] = None
    ) -> str:
        """Generate a complete test file for multiple properties.
        
        Args:
            properties: List of CorrectnessProperty objects
            spec_id: Specification ID for traceability
            spec_name: Specification name
            output_path: Optional output file path
            
        Returns:
            Generated test file content
        """
        # Collect all requirement IDs
        all_req_ids = set()
        for prop in properties:
            all_req_ids.update(prop.requirement_ids)
        
        # Generate file header
        header = self.FILE_HEADER_TEMPLATE.format(
            spec_name=spec_name,
            timestamp=datetime.now().isoformat(),
            spec_id=spec_id,
            requirement_ids=', '.join(sorted(all_req_ids)),
        )
        
        # Generate test functions
        test_functions = []
        for prop in properties:
            test_code = self._generate_test_function(prop)
            test_functions.append(test_code)
        
        # Combine into complete file
        file_content = header + '\n'.join(test_functions)
        
        return file_content
    
    def validate_test_syntax(self, test_code: str) -> bool:
        """Validate that generated test code has valid Python syntax.
        
        Args:
            test_code: Python test code to validate
            
        Returns:
            True if syntax is valid, False otherwise
        """
        try:
            ast.parse(test_code)
            return True
        except SyntaxError:
            return False
    
    def _generate_test_code(self, prop: CorrectnessProperty, test_name: str) -> str:
        """Generate test code for a property.
        
        Args:
            prop: CorrectnessProperty to generate code for
            test_name: Sanitized test name
            
        Returns:
            Test code string
        """
        # Select generation strategy based on pattern
        if prop.pattern == PropertyPattern.ROUND_TRIP:
            return self._generate_round_trip_test(prop, test_name)
        elif prop.pattern == PropertyPattern.IDEMPOTENCE:
            return self._generate_idempotence_test(prop, test_name)
        elif prop.pattern == PropertyPattern.INVARIANT:
            return self._generate_invariant_test(prop, test_name)
        elif prop.pattern == PropertyPattern.METAMORPHIC:
            return self._generate_metamorphic_test(prop, test_name)
        elif prop.pattern == PropertyPattern.ERROR_CONDITION:
            return self._generate_error_condition_test(prop, test_name)
        else:
            return self._generate_generic_test(prop, test_name)
    
    def _generate_test_function(self, prop: CorrectnessProperty) -> str:
        """Generate a complete test function for a property.
        
        Args:
            prop: CorrectnessProperty to generate function for
            
        Returns:
            Complete test function code
        """
        test_name = self._sanitize_name(prop.name)
        
        # Generate generators string
        generators_str = self._generate_generators_string(prop)
        
        # Generate parameters string
        params_str = self._generate_params_string(prop)
        
        # Generate test body
        test_body = self._generate_test_body(prop)
        
        # Format preconditions and postconditions
        preconditions = '\n'.join(f'    - {p}' for p in prop.preconditions) or '    - None'
        postconditions = '\n'.join(f'    - {p}' for p in prop.postconditions) or '    - None'
        
        return self.TEST_FUNCTION_TEMPLATE.format(
            iterations=100,
            generators=generators_str,
            test_name=test_name,
            params=params_str,
            property_name=prop.name,
            description=prop.description,
            universal_quantifier=prop.universal_quantifier,
            property_statement=prop.property_statement,
            property_id=prop.id,
            requirement_ids=', '.join(prop.requirement_ids),
            pattern=prop.pattern.value,
            preconditions=preconditions,
            postconditions=postconditions,
            test_body=test_body,
        )
    
    def _generate_round_trip_test(self, prop: CorrectnessProperty, test_name: str) -> str:
        """Generate a round-trip property test.
        
        Args:
            prop: CorrectnessProperty with round-trip pattern
            test_name: Test name
            
        Returns:
            Round-trip test code
        """
        return textwrap.dedent(f'''
            @settings(max_examples=100, deadline=None)
            @given(data=st.data())
            def test_{test_name}(data):
                """Round-trip property test.
                
                Property: {prop.property_statement}
                Requirements: {', '.join(prop.requirement_ids)}
                """
                # Generate input data
                input_value = data.draw(st.text(min_size=1, max_size=100))
                
                # Apply forward transformation
                # TODO: Replace with actual encode/serialize function
                encoded = input_value.encode('utf-8') if isinstance(input_value, str) else input_value
                
                # Apply reverse transformation
                # TODO: Replace with actual decode/deserialize function
                decoded = encoded.decode('utf-8') if isinstance(encoded, bytes) else encoded
                
                # Verify round-trip property
                assert decoded == input_value, f"Round-trip failed: {{input_value}} -> {{encoded}} -> {{decoded}}"
        ''')
    
    def _generate_idempotence_test(self, prop: CorrectnessProperty, test_name: str) -> str:
        """Generate an idempotence property test.
        
        Args:
            prop: CorrectnessProperty with idempotence pattern
            test_name: Test name
            
        Returns:
            Idempotence test code
        """
        return textwrap.dedent(f'''
            @settings(max_examples=100, deadline=None)
            @given(data=st.data())
            def test_{test_name}(data):
                """Idempotence property test.
                
                Property: {prop.property_statement}
                Requirements: {', '.join(prop.requirement_ids)}
                """
                # Generate input data
                input_value = data.draw(st.integers())
                
                # Apply operation once
                # TODO: Replace with actual idempotent operation
                result_once = abs(input_value)
                
                # Apply operation twice
                result_twice = abs(result_once)
                
                # Verify idempotence: f(f(x)) == f(x)
                assert result_twice == result_once, f"Idempotence failed: f({{input_value}})={{result_once}}, f(f({{input_value}}))={{result_twice}}"
        ''')
    
    def _generate_invariant_test(self, prop: CorrectnessProperty, test_name: str) -> str:
        """Generate an invariant property test.
        
        Args:
            prop: CorrectnessProperty with invariant pattern
            test_name: Test name
            
        Returns:
            Invariant test code
        """
        return textwrap.dedent(f'''
            @settings(max_examples=100, deadline=None)
            @given(data=st.data())
            def test_{test_name}(data):
                """Invariant property test.
                
                Property: {prop.property_statement}
                Requirements: {', '.join(prop.requirement_ids)}
                """
                # Generate initial state
                initial_state = data.draw(st.dictionaries(
                    st.text(min_size=1, max_size=20),
                    st.integers(),
                    min_size=1,
                    max_size=10
                ))
                
                # Define invariant check
                def check_invariant(state):
                    # TODO: Replace with actual invariant check
                    return isinstance(state, dict)
                
                # Verify invariant holds before operation
                assert check_invariant(initial_state), "Invariant violated before operation"
                
                # Apply operation
                # TODO: Replace with actual operation
                modified_state = dict(initial_state)
                modified_state['_modified'] = True
                
                # Verify invariant holds after operation
                assert check_invariant(modified_state), "Invariant violated after operation"
        ''')
    
    def _generate_metamorphic_test(self, prop: CorrectnessProperty, test_name: str) -> str:
        """Generate a metamorphic property test.
        
        Args:
            prop: CorrectnessProperty with metamorphic pattern
            test_name: Test name
            
        Returns:
            Metamorphic test code
        """
        return textwrap.dedent(f'''
            @settings(max_examples=100, deadline=None)
            @given(data=st.data())
            def test_{test_name}(data):
                """Metamorphic property test.
                
                Property: {prop.property_statement}
                Requirements: {', '.join(prop.requirement_ids)}
                """
                # Generate source input
                source_input = data.draw(st.lists(st.integers(), min_size=1, max_size=50))
                
                # Apply source operation
                # TODO: Replace with actual operation
                source_output = sorted(source_input)
                
                # Generate follow-up input (metamorphic relation)
                follow_up_input = source_input + [0]  # Add element
                
                # Apply follow-up operation
                follow_up_output = sorted(follow_up_input)
                
                # Verify metamorphic relation
                # Adding an element should result in output with one more element
                assert len(follow_up_output) == len(source_output) + 1, \\
                    f"Metamorphic relation violated: {{len(source_output)}} + 1 != {{len(follow_up_output)}}"
        ''')
    
    def _generate_error_condition_test(self, prop: CorrectnessProperty, test_name: str) -> str:
        """Generate an error condition property test.
        
        Args:
            prop: CorrectnessProperty with error condition pattern
            test_name: Test name
            
        Returns:
            Error condition test code
        """
        return textwrap.dedent(f'''
            @settings(max_examples=100, deadline=None)
            @given(data=st.data())
            def test_{test_name}(data):
                """Error condition property test.
                
                Property: {prop.property_statement}
                Requirements: {', '.join(prop.requirement_ids)}
                """
                # Generate invalid input
                invalid_input = data.draw(st.one_of(
                    st.none(),
                    st.just(""),
                    st.integers(max_value=-1),
                ))
                
                # Verify error handling
                # TODO: Replace with actual function and expected exception
                try:
                    # Attempt operation with invalid input
                    if invalid_input is None:
                        raise ValueError("Input cannot be None")
                    if invalid_input == "":
                        raise ValueError("Input cannot be empty")
                    if isinstance(invalid_input, int) and invalid_input < 0:
                        raise ValueError("Input cannot be negative")
                    
                    # If we get here, the function didn't raise as expected
                    # This is acceptable if the input was actually valid
                except ValueError as e:
                    # Expected error was raised
                    note(f"Correctly raised error: {{e}}")
                except Exception as e:
                    # Unexpected error type
                    pytest.fail(f"Unexpected error type: {{type(e).__name__}}: {{e}}")
        ''')
    
    def _generate_generic_test(self, prop: CorrectnessProperty, test_name: str) -> str:
        """Generate a generic property test.
        
        Args:
            prop: CorrectnessProperty
            test_name: Test name
            
        Returns:
            Generic test code
        """
        return textwrap.dedent(f'''
            @settings(max_examples=100, deadline=None)
            @given(data=st.data())
            def test_{test_name}(data):
                """Generic property test.
                
                Property: {prop.property_statement}
                Requirements: {', '.join(prop.requirement_ids)}
                """
                # Generate input based on property input types
                input_value = data.draw(st.text(min_size=0, max_size=100))
                
                # TODO: Implement property verification
                # This is a placeholder that should be customized
                
                # Log the input for debugging
                note(f"Testing with input: {{input_value}}")
                
                # Basic assertion - replace with actual property check
                assert True, "Property verification not implemented"
        ''')
    
    def _generate_test_body(self, prop: CorrectnessProperty) -> str:
        """Generate the body of a test function.
        
        Args:
            prop: CorrectnessProperty to generate body for
            
        Returns:
            Test body code
        """
        # Generate based on pattern
        if prop.pattern == PropertyPattern.ROUND_TRIP:
            return self._generate_round_trip_body(prop)
        elif prop.pattern == PropertyPattern.IDEMPOTENCE:
            return self._generate_idempotence_body(prop)
        elif prop.pattern == PropertyPattern.INVARIANT:
            return self._generate_invariant_body(prop)
        elif prop.pattern == PropertyPattern.METAMORPHIC:
            return self._generate_metamorphic_body(prop)
        elif prop.pattern == PropertyPattern.ERROR_CONDITION:
            return self._generate_error_body(prop)
        else:
            return self._generate_generic_body(prop)
    
    def _generate_round_trip_body(self, prop: CorrectnessProperty) -> str:
        """Generate round-trip test body."""
        return textwrap.indent(textwrap.dedent('''
            # Round-trip property: encode(decode(x)) == x
            # TODO: Replace with actual encode/decode functions
            encoded = data.encode('utf-8') if isinstance(data, str) else str(data).encode('utf-8')
            decoded = encoded.decode('utf-8')
            
            # For string inputs, verify round-trip
            if isinstance(data, str):
                assert decoded == data, f"Round-trip failed: {data} != {decoded}"
        '''), '    ')
    
    def _generate_idempotence_body(self, prop: CorrectnessProperty) -> str:
        """Generate idempotence test body."""
        return textwrap.indent(textwrap.dedent('''
            # Idempotence property: f(f(x)) == f(x)
            # TODO: Replace with actual idempotent operation
            def operation(x):
                return abs(x) if isinstance(x, (int, float)) else x
            
            result_once = operation(data)
            result_twice = operation(result_once)
            
            assert result_twice == result_once, f"Idempotence violated: f(f({data})) = {result_twice} != f({data}) = {result_once}"
        '''), '    ')
    
    def _generate_invariant_body(self, prop: CorrectnessProperty) -> str:
        """Generate invariant test body."""
        return textwrap.indent(textwrap.dedent('''
            # Invariant property: invariant(before) implies invariant(after)
            # TODO: Replace with actual invariant check and operation
            def check_invariant(state):
                return state is not None
            
            # Check invariant before
            assert check_invariant(data), f"Invariant violated before operation: {data}"
            
            # Apply operation (placeholder)
            result = data
            
            # Check invariant after
            assert check_invariant(result), f"Invariant violated after operation: {result}"
        '''), '    ')
    
    def _generate_metamorphic_body(self, prop: CorrectnessProperty) -> str:
        """Generate metamorphic test body."""
        return textwrap.indent(textwrap.dedent('''
            # Metamorphic property: relationship between inputs and outputs
            # TODO: Replace with actual metamorphic relation
            
            # Source execution
            source_result = len(data) if hasattr(data, '__len__') else 1
            
            # Follow-up execution with transformed input
            if isinstance(data, str):
                follow_up_input = data + "x"
                follow_up_result = len(follow_up_input)
                
                # Verify metamorphic relation: adding char increases length by 1
                assert follow_up_result == source_result + 1, \\
                    f"Metamorphic relation violated: {source_result} + 1 != {follow_up_result}"
        '''), '    ')
    
    def _generate_error_body(self, prop: CorrectnessProperty) -> str:
        """Generate error condition test body."""
        return textwrap.indent(textwrap.dedent('''
            # Error condition property: proper error handling
            # TODO: Replace with actual error condition check
            
            # Test that invalid inputs are handled properly
            try:
                if data is None:
                    raise ValueError("None input not allowed")
                # Operation succeeded - input was valid
                note(f"Valid input accepted: {data}")
            except ValueError as e:
                # Expected error for invalid input
                note(f"Invalid input correctly rejected: {e}")
            except Exception as e:
                pytest.fail(f"Unexpected error: {type(e).__name__}: {e}")
        '''), '    ')
    
    def _generate_generic_body(self, prop: CorrectnessProperty) -> str:
        """Generate generic test body."""
        return textwrap.indent(textwrap.dedent(f'''
            # Generic property test
            # Property: {prop.property_statement}
            
            note(f"Testing with input: {{data}}")
            
            # TODO: Implement actual property verification
            # Placeholder assertion
            assert True, "Property verification not yet implemented"
        '''), '    ')
    
    def _generate_generators_string(self, prop: CorrectnessProperty) -> str:
        """Generate the generators string for @given decorator.
        
        Args:
            prop: CorrectnessProperty
            
        Returns:
            Generators string for decorator
        """
        # Map input types to Hypothesis strategies
        type_to_strategy = {
            'int': 'st.integers()',
            'str': 'st.text(min_size=0, max_size=100)',
            'float': 'st.floats(allow_nan=False)',
            'bool': 'st.booleans()',
            'list': 'st.lists(st.integers(), max_size=20)',
            'dict': 'st.dictionaries(st.text(max_size=10), st.integers(), max_size=10)',
            'Any': 'st.one_of(st.integers(), st.text(max_size=50), st.booleans())',
        }
        
        if not prop.input_types:
            return 'data=st.data()'
        
        generators = []
        for i, input_type in enumerate(prop.input_types):
            param_name = f'input_{i}' if len(prop.input_types) > 1 else 'data'
            strategy = type_to_strategy.get(input_type, 'st.text(max_size=100)')
            generators.append(f'{param_name}={strategy}')
        
        return ', '.join(generators)
    
    def _generate_params_string(self, prop: CorrectnessProperty) -> str:
        """Generate the parameters string for test function.
        
        Args:
            prop: CorrectnessProperty
            
        Returns:
            Parameters string
        """
        if not prop.input_types:
            return 'data'
        
        if len(prop.input_types) == 1:
            return 'data'
        
        return ', '.join(f'input_{i}' for i in range(len(prop.input_types)))
    
    def _identify_generators(self, prop: CorrectnessProperty) -> List[str]:
        """Identify generators needed for a property.
        
        Args:
            prop: CorrectnessProperty
            
        Returns:
            List of generator names
        """
        generators = []
        
        for input_type in prop.input_types:
            if input_type.lower() in ['int', 'integer']:
                generators.append('st.integers')
            elif input_type.lower() in ['str', 'string', 'text']:
                generators.append('st.text')
            elif input_type.lower() in ['float', 'double']:
                generators.append('st.floats')
            elif input_type.lower() in ['bool', 'boolean']:
                generators.append('st.booleans')
            elif input_type.lower() in ['list', 'array']:
                generators.append('st.lists')
            elif input_type.lower() in ['dict', 'dictionary', 'map']:
                generators.append('st.dictionaries')
            else:
                generators.append('st.data')
        
        return generators
    
    def _sanitize_name(self, name: str) -> str:
        """Sanitize a name for use as a Python identifier.
        
        Args:
            name: Original name
            
        Returns:
            Sanitized name valid as Python identifier
        """
        # Replace spaces and special characters with underscores
        sanitized = name.lower()
        sanitized = ''.join(c if c.isalnum() else '_' for c in sanitized)
        
        # Remove consecutive underscores
        while '__' in sanitized:
            sanitized = sanitized.replace('__', '_')
        
        # Remove leading/trailing underscores
        sanitized = sanitized.strip('_')
        
        # Ensure it starts with a letter
        if sanitized and not sanitized[0].isalpha():
            sanitized = 'test_' + sanitized
        
        return sanitized or 'unnamed_test'


def generate_test_from_property(prop: CorrectnessProperty) -> GeneratedTest:
    """Convenience function to generate a test from a property.
    
    Args:
        prop: CorrectnessProperty to generate test for
        
    Returns:
        GeneratedTest object
    """
    generator = PropertyTestGenerator()
    return generator.generate_test(prop)


def generate_test_file(
    properties: List[CorrectnessProperty],
    spec_id: str,
    spec_name: str
) -> str:
    """Convenience function to generate a test file.
    
    Args:
        properties: List of CorrectnessProperty objects
        spec_id: Specification ID
        spec_name: Specification name
        
    Returns:
        Test file content
    """
    generator = PropertyTestGenerator()
    return generator.generate_test_file(properties, spec_id, spec_name)
